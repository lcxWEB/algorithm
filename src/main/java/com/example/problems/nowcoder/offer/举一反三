1. 替换空格
    在合并两个数组（包括字符串）时，如果从前往后复制每个数字，需要重复移动数字多次，那么可以考虑从后往前复制，这样就能减少移动的次数，提高效率。

2. 第一个只出现一次的字符
    如果需要判断多个字符是不是在某个字符串里出现过或者统计多个字符在某个字符串中出现的次数，那么我们可以考虑基于数组创建一个简单的哈希表，这样可以用很小的空间消耗换来时间效率的提升。

3. 通常物体或者人在二维方格运动这类问题都可以用回溯法解决。

4. 求最优解，且可以分解为若干个小问题，且子问题之间还有重叠的更小的子问题，就可以考虑动态规划。
   这类问题的4个特点：求最优解；整体问题的最优解依赖各个子问题的最优解；分解的若干小问题之间还有相互重叠的更小的问题；自上而下的递归思路分析问题，自下而上基于循环求解问题

5. 在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，那么可以尝试使用二分查找

6. 把一个整数减1之后与原来的整数做与运算，得到的结果相当于把整数的二进制表示中最右边的1变成0。

7. 当用一个指针遍历链表不能解决问题的时候，尝试用两个指针来遍历链表。可以让其中一个指针遍历得快一些（比如一次在链表上走两步），或者让他先在链表上走若干步

8. 与二叉树相关的代码有大量的指针操作，在每次使用指针的时候，我们都要问自己这个指针有没有可能是null，如果是null则该怎么处理。

9. 由于计算机表示小数（float和double）都有误差，我们不能直接用等号（==）判断两个小数是否相等。如果两个小数的差的绝对值很小，如小于0.0000001，就可以认为它们相等。

10. 不管是广度优先遍历一幅有向图还是一棵树，都要用到队列。首先把起始节点（对树而言是根结点）放入队列。接下来每次从队列的头部取出一个节点，
    遍历这个节点之后把它能到达的节点（对树而言是子节点）都依次放入队列。重复这个遍历过程，直到队列中的节点全部被遍历为止。

11. 如果面试题要处理一棵二叉树的遍历序列，则可以先找到根节点，再基于根节点把整棵树的遍历序列拆分成左子树对应的子序列和右子树对应的子序列，
    再来递归得处理这两个子序列。如：重建二叉树、判断一个数组是否是二叉搜索树的后序遍历序列

12. 递归调用自动回到它的父节点